Index: src/chrome/common/chrome_switches.cc
===================================================================
--- src.orig/chrome/common/chrome_switches.cc	2010-08-16 15:13:09.593640827 +0200
+++ src/chrome/common/chrome_switches.cc	2010-08-16 15:50:48.343643415 +0200
@@ -525,6 +525,9 @@
 // These mappings only apply to the host resolver.
 const char kHostResolverRules[]             = "host-resolver-rules";
 
+// Specifies the icon_id in order to use the correct icon.
+const char kIconId[]                         = "icon-id";
+
 // Perform importing from another browser. The value associated with this
 // setting encodes the target browser and what items to import.
 const char kImport[]                        = "import";
Index: src/chrome/browser/gtk/gtk_util.cc
===================================================================
--- src.orig/chrome/browser/gtk/gtk_util.cc	2010-08-16 15:13:09.583648138 +0200
+++ src/chrome/browser/gtk/gtk_util.cc	2010-08-16 15:50:42.133646469 +0200
@@ -14,6 +14,7 @@
 #include "app/l10n_util.h"
 #include "app/resource_bundle.h"
 #include "app/x11_util.h"
+#include "base/command_line.h"
 #include "base/gtk_util.h"
 #include "base/i18n/rtl.h"
 #include "base/linux_util.h"
@@ -23,6 +24,7 @@
 #include "chrome/browser/browser_window.h"
 #include "chrome/browser/gtk/cairo_cached_surface.h"
 #include "chrome/browser/gtk/gtk_theme_provider.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/renderer_preferences.h"
 #include "googleurl/src/gurl.h"
 #include "grit/theme_resources.h"
@@ -71,15 +73,6 @@
   return TRUE;
 }
 
-// Ownership of |icon_list| is passed to the caller.
-GList* GetIconList() {
-  ResourceBundle& rb = ResourceBundle::GetSharedInstance();
-  GList* icon_list = NULL;
-  icon_list = g_list_append(icon_list, rb.GetPixbufNamed(IDR_PRODUCT_ICON_32));
-  icon_list = g_list_append(icon_list, rb.GetPixbufNamed(IDR_PRODUCT_LOGO_16));
-  return icon_list;
-}
-
 // A process wide singleton that manages our usage of gdk
 // cursors. gdk_cursor_new() hits the disk in several places and GdkCursor
 // instances can be reused throughout the process.
@@ -150,6 +143,48 @@
 
 namespace gtk_util {
 
+// Ownership of |icon_list| is passed to the caller.
+GList* ProductIconList() {
+  ResourceBundle& rb = ResourceBundle::GetSharedInstance();
+  GList* icon_list = NULL;
+  icon_list = g_list_append(icon_list, rb.GetPixbufNamed(IDR_PRODUCT_ICON_32));
+  icon_list = g_list_append(icon_list, rb.GetPixbufNamed(IDR_PRODUCT_LOGO_16));
+  return icon_list;
+}
+
+GdkPixbuf* GetPixbufFromIconID(const std::string& icon_id) {
+  GdkPixbuf* icon_pixbuf = NULL;
+  GError* error = NULL;
+  GtkIconTheme* icon_theme = gtk_icon_theme_get_default();
+
+  if (!icon_id.empty() && gtk_icon_theme_has_icon(icon_theme, icon_id.c_str())) {
+    icon_pixbuf = gtk_icon_theme_load_icon(icon_theme, icon_id.c_str(), 64, GTK_ICON_LOOKUP_USE_BUILTIN, &error);
+    if (!icon_pixbuf) {
+      g_warning("Couldn't load icon: %s", error->message);
+      g_error_free(error);
+    }
+  }
+  return icon_pixbuf;
+}
+
+GList* GetIconList() {
+  GList* icon_list = NULL;
+
+  const CommandLine& parsed_command_line = *CommandLine::ForCurrentProcess();
+  const std::string& icon_id =
+      parsed_command_line.GetSwitchValueASCII(switches::kIconId);
+
+  GdkPixbuf* icon_pixbuf = GetPixbufFromIconID(icon_id);
+  if (icon_pixbuf) {
+    icon_list = g_list_append(icon_list, icon_pixbuf);
+  }
+  else {
+    icon_list = ProductIconList();
+  }
+
+  return icon_list;
+}
+
 GtkWidget* CreateLabeledControlsGroup(std::vector<GtkWidget*>* labels,
                                       const char* text, ...) {
   va_list ap;
@@ -515,13 +550,13 @@
 }
 
 void SetWindowIcon(GtkWindow* window) {
-  GList* icon_list = GetIconList();
+  GList* icon_list = gtk_util::GetIconList();
   gtk_window_set_icon_list(window, icon_list);
   g_list_free(icon_list);
 }
 
 void SetDefaultWindowIcon() {
-  GList* icon_list = GetIconList();
+  GList* icon_list = gtk_util::ProductIconList();
   gtk_window_set_default_icon_list(icon_list);
   g_list_free(icon_list);
 }
Index: src/chrome/common/chrome_switches.h
===================================================================
--- src.orig/chrome/common/chrome_switches.h	2010-08-16 15:13:09.593640827 +0200
+++ src/chrome/common/chrome_switches.h	2010-08-16 15:50:48.333642098 +0200
@@ -26,6 +26,7 @@
 extern const char kAlwaysEnableDevTools[];
 extern const char kApp[];
 extern const char kAppId[];
+extern const char kIconId[];
 extern const char kAppLaunchAsPanel[];
 extern const char kAppsDebug[];
 extern const char kAppsPanel[];
Index: src/chrome/browser/browser.cc
===================================================================
--- src.orig/chrome/browser/browser.cc	2010-08-16 15:15:39.643641141 +0200
+++ src/chrome/browser/browser.cc	2010-08-16 15:52:13.863640886 +0200
@@ -16,6 +16,7 @@
 #include "app/l10n_util.h"
 #include "base/base_paths.h"
 #include "base/command_line.h"
+#include "base/file_path.h"
 #include "base/keyboard_codes.h"
 #include "base/logging.h"
 #include "base/path_service.h"
@@ -483,6 +484,7 @@
 }
 
 // static
+const FilePath::CharType kEmptyIcon[] = FILE_PATH_LITERAL("");
 // TODO(erikkay): There are multiple reasons why this could fail.  Should
 // this function return an error reason as well so that callers can show
 // reasonable errors?
@@ -527,11 +529,12 @@
   }
 
   // The app is not yet open.  Load it.
+  FilePath empty_icon(kEmptyIcon);
   switch (container) {
     case Extension::LAUNCH_WINDOW:
     case Extension::LAUNCH_PANEL:
       tab = Browser::OpenApplicationWindow(profile, extension, container,
-                                           GURL());
+                                           GURL(), empty_icon);
       break;
     case Extension::LAUNCH_TAB: {
       tab = Browser::OpenApplicationTab(profile, extension);
@@ -554,7 +557,8 @@
     Profile* profile,
     Extension* extension,
     Extension::LaunchContainer container,
-    const GURL& url_input) {
+    const GURL& url_input,
+    const FilePath& icon_id) {
   GURL url;
   if (!url_input.is_empty()) {
     if (extension)
@@ -572,6 +576,15 @@
   bool as_panel = extension && (container == Extension::LAUNCH_PANEL);
   Browser* browser = Browser::CreateForApp(app_name, extension, profile,
                                            as_panel);
+
+  // save icon-id value for later use by UpdateWindowIcon
+  if (!icon_id.empty()) {
+      std::wstring icon_pref_key = browser->GetWindowIconKey();
+      PrefService* prefs = g_browser_process->local_state();
+      DCHECK(prefs);
+      prefs->SetFilePath(icon_pref_key.c_str(), icon_id);
+  }
+
   TabContents* tab_contents = browser->AddTabWithURL(
       url, GURL(), PageTransition::START_PAGE, -1, TabStripModel::ADD_SELECTED,
       NULL, std::string());
@@ -599,8 +612,8 @@
 
 // static
 TabContents* Browser::OpenApplicationWindow(Profile* profile,
-                                            GURL& url) {
-  return OpenApplicationWindow(profile, NULL, Extension::LAUNCH_WINDOW, url);
+                                            GURL& url, const FilePath& icon_id) {
+  return OpenApplicationWindow(profile, NULL, Extension::LAUNCH_WINDOW, url, icon_id);
 }
 
 // static
@@ -668,6 +681,15 @@
 ///////////////////////////////////////////////////////////////////////////////
 // Browser, State Storage and Retrieval for UI:
 
+std::wstring Browser::GetWindowIconKey() const {
+  std::wstring name(prefs::kBrowserWindowIcon);
+  if (!app_name_.empty()) {
+    name.append(L"_");
+    name.append(app_name_);
+  }
+  return name;
+}
+
 std::wstring Browser::GetWindowPlacementKey() const {
   std::wstring name(prefs::kBrowserWindowPlacement);
   if (!app_name_.empty()) {
@@ -740,6 +762,18 @@
   return contents ? contents->GetFavIcon() : SkBitmap();
 }
 
+GURL Browser::GetURLForCurrentTab() const {
+  TabContents* contents = tabstrip_model_.GetSelectedTabContents();
+  GURL url;
+
+  // |contents| can be NULL because GetWindowTitleForCurrentTab is called by the
+  // window during the window's creation (before tabs have been added).
+  if (contents)
+    url = contents->GetURL();
+
+  return url;
+}
+
 string16 Browser::GetWindowTitleForCurrentTab() const {
   TabContents* contents = tabstrip_model_.GetSelectedTabContents();
   string16 title;
@@ -1879,6 +1913,7 @@
 // static
 void Browser::RegisterPrefs(PrefService* prefs) {
   prefs->RegisterDictionaryPref(prefs::kBrowserWindowPlacement);
+  prefs->RegisterFilePathPref(prefs::kBrowserWindowIcon, FilePath());
   prefs->RegisterIntegerPref(prefs::kOptionsWindowLastTabIndex, 0);
   prefs->RegisterIntegerPref(prefs::kDevToolsSplitLocation, -1);
   prefs->RegisterDictionaryPref(prefs::kPreferencesWindowPlacement);
@@ -3718,8 +3753,9 @@
     // existing window, create one, then open the URL there.
     if (destination_extension->launch_container() ==
         Extension::LAUNCH_WINDOW) {
+      FilePath empty_icon(kEmptyIcon);
       Browser::OpenApplicationWindow(profile_, destination_extension,
-                                     Extension::LAUNCH_WINDOW, url);
+                                     Extension::LAUNCH_WINDOW, url, empty_icon);
       return true;
     }
   }
@@ -4021,10 +4057,14 @@
   std::wstring window_pref(prefs::kBrowserWindowPlacement);
   window_pref.append(L"_");
   window_pref.append(app_name);
+  std::wstring icon_pref(prefs::kBrowserWindowIcon);
+  icon_pref.append(L"_");
+  icon_pref.append(app_name);
   PrefService* prefs = g_browser_process->local_state();
   DCHECK(prefs);
 
   prefs->RegisterDictionaryPref(window_pref.c_str());
+  prefs->RegisterFilePathPref(icon_pref.c_str(), FilePath());
 }
 
 // static
Index: src/chrome/browser/gtk/browser_titlebar.cc
===================================================================
--- src.orig/chrome/browser/gtk/browser_titlebar.cc	2010-08-16 15:13:09.563646967 +0200
+++ src/chrome/browser/gtk/browser_titlebar.cc	2010-08-16 15:50:48.323641240 +0200
@@ -13,11 +13,13 @@
 #include "app/l10n_util.h"
 #include "app/resource_bundle.h"
 #include "base/command_line.h"
+#include "base/logging.h"
 #include "base/singleton.h"
 #include "base/string_piece.h"
 #include "base/string_tokenizer.h"
 #include "chrome/app/chrome_dll_resource.h"
 #include "chrome/browser/browser.h"
+#include "chrome/browser/browser_process.h"
 #include "chrome/browser/encoding_menu_controller.h"
 #include "chrome/browser/gtk/accelerators_gtk.h"
 #include "chrome/browser/gtk/browser_window_gtk.h"
@@ -496,14 +498,31 @@
     // Update the system app icon.  We don't need to update the icon in the top
     // left of the custom frame, that will get updated when the throbber is
     // updated.
-    SkBitmap icon = browser_window_->browser()->GetCurrentPageIcon();
-    if (icon.empty()) {
-      gtk_util::SetWindowIcon(window_);
-    } else {
-      GdkPixbuf* icon_pixbuf = gfx::GdkPixbufFromSkBitmap(&icon);
-      gtk_window_set_icon(window_, icon_pixbuf);
-      g_object_unref(icon_pixbuf);
+    // If we got an icon-id parameter (saved into prefs) and the current URL is a subpath of
+    // the app parameter use the icon-id icon
+
+    std::wstring current_host = UTF8ToWide(browser_window_->browser()->GetURLForCurrentTab().host());
+
+    GList* icon_list = NULL;
+    GdkPixbuf* icon_pixbuf = NULL;
+    std::wstring icon_pref_key = browser_window_->browser()->GetWindowIconKey();
+    size_t found = icon_pref_key.find(current_host);
+    PrefService* prefs = g_browser_process->local_state();
+    FilePath prefs_icon_id = prefs->GetFilePath(icon_pref_key.c_str());
+    if (!prefs_icon_id.empty())
+      icon_pixbuf = gtk_util::GetPixbufFromIconID(prefs_icon_id.value());
+    // The current URL is foreign, use the default app icons
+    if (found == std::string::npos) {
+      icon_list = gtk_util::ProductIconList();
+    }
+    else if (icon_pixbuf) {
+      icon_list = g_list_append(icon_list, icon_pixbuf);
+    }
+    else {
+      gtk_util::GetIconList();
     }
+    gtk_window_set_icon_list(window_, icon_list);
+    g_list_free(icon_list);
   }
 }
 
Index: src/chrome/browser/browser.h
===================================================================
--- src.orig/chrome/browser/browser.h	2010-08-16 15:13:09.553640801 +0200
+++ src/chrome/browser/browser.h	2010-08-16 15:50:48.273644134 +0200
@@ -230,11 +230,13 @@
       Profile* profile,
       Extension* extension,
       Extension::LaunchContainer container,
-      const GURL& url);
+      const GURL& url,
+      const FilePath& icon_id);
 
   // Open an application for |extension| in a new application window or panel.
   static TabContents* OpenApplicationWindow(Profile* profile,
-                                            GURL& url);
+                                            GURL& url,
+                                            const FilePath& icon_id);
 
   // Open an application for |extension| in a new application tab.  Returns
   // NULL if there are no appropriate existing browser windows for |profile|.
@@ -260,6 +262,7 @@
   // State Storage and Retrieval for UI ///////////////////////////////////////
 
   // Save and restore the window position.
+  std::wstring GetWindowIconKey() const;
   std::wstring GetWindowPlacementKey() const;
   bool ShouldSaveWindowPlacement() const;
   void SaveWindowPlacement(const gfx::Rect& bounds, bool maximized);
@@ -269,6 +272,9 @@
   // Gets the FavIcon of the page in the selected tab.
   SkBitmap GetCurrentPageIcon() const;
 
+  // Gets the URL of the current tab.
+  GURL GetURLForCurrentTab() const;
+
   // Gets the title of the window based on the selected tab's title.
   string16 GetWindowTitleForCurrentTab() const;
 
Index: src/chrome/browser/gtk/gtk_util.h
===================================================================
--- src.orig/chrome/browser/gtk/gtk_util.h	2010-08-16 15:13:09.573641268 +0200
+++ src/chrome/browser/gtk/gtk_util.h	2010-08-16 15:50:42.133646469 +0200
@@ -53,6 +53,10 @@
 // Horizontal Spacing between controls in a form.
 const int kFormControlSpacing = 10;
 
+GdkPixbuf* GetPixbufFromIconID(const std::string& icon_id);
+GList* GetIconList();
+GList* ProductIconList();
+
 // Create a table of labeled controls, using proper spacing and alignment.
 // Arguments should be pairs of const char*, GtkWidget*, concluding with a
 // NULL.  The first argument is a vector in which to place all labels
Index: src/chrome/common/pref_names.cc
===================================================================
--- src.orig/chrome/common/pref_names.cc	2010-08-16 15:13:09.583648138 +0200
+++ src/chrome/common/pref_names.cc	2010-08-16 15:50:42.143642521 +0200
@@ -657,6 +657,9 @@
 // window to restore on startup.
 const wchar_t kBrowserWindowPlacement[] = L"browser.window_placement";
 
+// Desktop Icon name
+const wchar_t kBrowserWindowIcon[] = L"browser.window_icon";
+
 // A collection of position, size, and other data relating to the task
 // manager window to restore on startup.
 const wchar_t kTaskManagerWindowPlacement[] = L"task_manager.window_placement";
Index: src/chrome/common/pref_names.h
===================================================================
--- src.orig/chrome/common/pref_names.h	2010-08-16 15:13:09.603647248 +0200
+++ src/chrome/common/pref_names.h	2010-08-16 15:50:42.143642521 +0200
@@ -236,6 +236,7 @@
 extern const wchar_t kUninstallLastObservedRunTimeSec[];
 
 extern const wchar_t kBrowserWindowPlacement[];
+extern const wchar_t kBrowserWindowIcon[];
 extern const wchar_t kTaskManagerWindowPlacement[];
 extern const wchar_t kPageInfoWindowPlacement[];
 extern const wchar_t kKeywordEditorWindowPlacement[];
Index: src/chrome/browser/browser_init.cc
===================================================================
--- src.orig/chrome/browser/browser_init.cc	2010-08-16 15:13:09.563646967 +0200
+++ src/chrome/browser/browser_init.cc	2010-08-16 15:50:48.293646917 +0200
@@ -651,7 +651,8 @@
         ChildProcessSecurityPolicy::GetInstance();
     if (policy->IsWebSafeScheme(url.scheme()) ||
         url.SchemeIs(chrome::kFileScheme)) {
-      Browser::OpenApplicationWindow(profile, url);
+      std::string icon_id(command_line_.GetSwitchValueASCII(switches::kIconId));
+      Browser::OpenApplicationWindow(profile, url, FilePath(icon_id));
       return true;
     }
   }
