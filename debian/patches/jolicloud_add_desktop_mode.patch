Index: src/chrome/browser/browser.cc
===================================================================
--- src.orig/chrome/browser/browser.cc	2010-08-16 15:52:13.863640886 +0200
+++ src/chrome/browser/browser.cc	2010-08-16 16:04:13.943641965 +0200
@@ -197,6 +197,7 @@
       block_command_execution_(false),
       last_blocked_command_id_(-1),
       last_blocked_command_disposition_(CURRENT_TAB),
+      kill_signal_(0),
       pending_web_app_action_(NONE),
       extension_app_(NULL) {
   tabstrip_model_.AddObserver(this);
@@ -301,6 +302,13 @@
 }
 
 // static
+Browser* Browser::CreateForDesktop(Profile* profile) {
+  Browser* browser = new Browser(TYPE_NORMAL_DESKTOP, profile);
+  browser->CreateBrowserWindow();
+  return browser;
+}
+
+// static
 Browser* Browser::CreateForPopup(Profile* profile) {
   Browser* browser = new Browser(TYPE_POPUP, profile);
   browser->CreateBrowserWindow();
@@ -336,6 +344,15 @@
 }
 
 // static
+Browser* Browser::CreateForAppDesktop(const std::wstring& app_name,
+                                      Profile* profile) {
+  Browser* browser = new Browser(TYPE_APP_DESKTOP, profile);
+  browser->app_name_ = app_name;
+  browser->CreateBrowserWindow();
+  return browser;
+}
+
+// static
 Browser* Browser::CreateForDevTools(Profile* profile) {
   Browser* browser = new Browser(TYPE_DEVTOOLS, profile);
   browser->app_name_ = DevToolsWindow::kDevToolsApp;
@@ -534,7 +551,7 @@
     case Extension::LAUNCH_WINDOW:
     case Extension::LAUNCH_PANEL:
       tab = Browser::OpenApplicationWindow(profile, extension, container,
-                                           GURL(), empty_icon);
+                                           GURL(), empty_icon, false);
       break;
     case Extension::LAUNCH_TAB: {
       tab = Browser::OpenApplicationTab(profile, extension);
@@ -558,7 +575,8 @@
     Extension* extension,
     Extension::LaunchContainer container,
     const GURL& url_input,
-    const FilePath& icon_id) {
+    const FilePath& icon_id,
+    bool as_desktop) {
   GURL url;
   if (!url_input.is_empty()) {
     if (extension)
@@ -574,8 +592,11 @@
   RegisterAppPrefs(app_name);
 
   bool as_panel = extension && (container == Extension::LAUNCH_PANEL);
-  Browser* browser = Browser::CreateForApp(app_name, extension, profile,
-                                           as_panel);
+  Browser* browser;
+  if (as_desktop)
+      browser = Browser::CreateForAppDesktop(app_name, profile);
+  else
+      browser = Browser::CreateForApp(app_name, extension, profile, as_panel);
 
   // save icon-id value for later use by UpdateWindowIcon
   if (!icon_id.empty()) {
@@ -589,6 +610,8 @@
       url, GURL(), PageTransition::START_PAGE, -1, TabStripModel::ADD_SELECTED,
       NULL, std::string());
 
+  if (browser->type_ & TYPE_DESKTOP)
+    browser->window()->SetDesktop();
   tab_contents->GetMutableRendererPrefs()->can_accept_load_drops = false;
   tab_contents->render_view_host()->SyncRendererPrefs();
   browser->window()->Show();
@@ -612,8 +635,8 @@
 
 // static
 TabContents* Browser::OpenApplicationWindow(Profile* profile,
-                                            GURL& url, const FilePath& icon_id) {
-  return OpenApplicationWindow(profile, NULL, Extension::LAUNCH_WINDOW, url, icon_id);
+                                            GURL& url, const FilePath& icon_id, bool as_desktop) {
+  return OpenApplicationWindow(profile, NULL, Extension::LAUNCH_WINDOW, url, icon_id, as_desktop);
 }
 
 // static
@@ -815,7 +838,9 @@
 // Browser, OnBeforeUnload handling:
 
 bool Browser::ShouldCloseWindow() {
-  if (!CanCloseWithInProgressDownloads())
+  if (!CanCloseWithInProgressDownloads()
+    || (this->type() & TYPE_DESKTOP && !kill_signal_)
+  )
     return false;
 
   if (HasCompletedUnloadProcessing())
@@ -1173,26 +1198,31 @@
   features |= FEATURE_DOWNLOADSHELF;
 #endif  // !defined(OS_CHROMEOS)
 
-  if (type() == TYPE_NORMAL) {
+  if (type() & TYPE_NORMAL) {
     features |= FEATURE_BOOKMARKBAR;
     features |= FEATURE_EXTENSIONSHELF;
   }
 
   if (!hide_ui_for_fullscreen) {
-    if (type() != TYPE_NORMAL && type() != TYPE_EXTENSION_APP)
+    if ( ((type() & TYPE_NORMAL) == 0 ) && type() != TYPE_EXTENSION_APP)
       features |= FEATURE_TITLEBAR;
 
-    if (type() == TYPE_NORMAL || type() == TYPE_EXTENSION_APP)
+    if (type() & TYPE_NORMAL || type() == TYPE_EXTENSION_APP)
       features |= FEATURE_TABSTRIP;
 
     // TODO(aa): This is kinda a hack. The toolbar is not really there, it is
     // collapsed. We probably want to add a FEATURE_MINI_TOOLBAR to represent
     // the collapsed state.
-    if (type() == TYPE_NORMAL || type() == TYPE_EXTENSION_APP)
+    if (type() & TYPE_NORMAL || type() == TYPE_EXTENSION_APP)
       features |= FEATURE_TOOLBAR;
 
     if (type() != TYPE_EXTENSION_APP && (type() & Browser::TYPE_APP) == 0)
       features |= FEATURE_LOCATIONBAR;
+
+    if (type() & TYPE_DESKTOP) {
+        features &= ~FEATURE_TITLEBAR;
+        features &= ~FEATURE_DOWNLOADSHELF;
+    }
   }
   return !!(features & feature);
 }
@@ -1472,7 +1502,7 @@
 
 void Browser::Exit() {
   UserMetrics::RecordAction(UserMetricsAction("Exit"), profile_);
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
 }
 
 void Browser::BookmarkCurrentPage() {
@@ -2363,7 +2393,7 @@
   // in-progress downloads.
   // Note that the next call when it returns false will ask the user for
   // confirmation before closing the browser if the user decides so.
-  return CanCloseWithInProgressDownloads();
+  return !((this->type() & TYPE_DESKTOP) && !kill_signal_) && CanCloseWithInProgressDownloads();
 }
 
 bool Browser::CanBookmarkAllTabs() const {
@@ -2797,6 +2827,10 @@
     return;
   }
 
+  if (this->type_ & TYPE_DESKTOP && !this->kill_signal_) {
+    proceed = false;
+  }
+
   if (!proceed) {
     CancelWindowClose();
     *proceed_to_fire_unload = false;
@@ -3755,7 +3789,7 @@
         Extension::LAUNCH_WINDOW) {
       FilePath empty_icon(kEmptyIcon);
       Browser::OpenApplicationWindow(profile_, destination_extension,
-                                     Extension::LAUNCH_WINDOW, url, empty_icon);
+                                     Extension::LAUNCH_WINDOW, url, empty_icon, false);
       return true;
     }
   }
Index: src/chrome/browser/browser.h
===================================================================
--- src.orig/chrome/browser/browser.h	2010-08-16 15:50:48.273644134 +0200
+++ src/chrome/browser/browser.h	2010-08-16 16:04:13.953646380 +0200
@@ -69,9 +69,12 @@
     // some other system (eg some web standard), maybe we should generalize this
     // name to TYPE_MULTITAB or something.
     TYPE_EXTENSION_APP = 8,
+    TYPE_DESKTOP = 32,
+    TYPE_NORMAL_DESKTOP = TYPE_DESKTOP | TYPE_NORMAL,
+    TYPE_APP_DESKTOP = TYPE_DESKTOP | TYPE_APP,
     TYPE_APP_POPUP = TYPE_APP | TYPE_POPUP,
-    TYPE_DEVTOOLS = TYPE_APP | 16,
-    TYPE_APP_PANEL = TYPE_APP | 32,
+    TYPE_DEVTOOLS = TYPE_APP | 64,
+    TYPE_APP_PANEL = TYPE_APP | 128,
     TYPE_ANY = TYPE_NORMAL |
                TYPE_POPUP |
                TYPE_APP |
@@ -118,6 +121,11 @@
   // window is created by this function call.
   static Browser* Create(Profile* profile);
 
+  // Creates a normal tabbed browser with the specified profile, but set as
+  // the user's desktop. The Browser's window is created by this function
+  // call.
+  static Browser* CreateForDesktop(Profile* profile);
+
   // Like Create, but creates a tabstrip-less popup window.
   static Browser* CreateForPopup(Profile* profile);
 
@@ -130,6 +138,10 @@
                                Profile* profile,
                                bool is_panel);
 
+  // Like Create, but creates a tabstrip-less and toolbar-less "app" window for
+  // the specified app, as the user's desktop.
+  static Browser* CreateForAppDesktop(const std::wstring& app_name, Profile* profile);
+
   // Like Create, but creates a tabstrip-less and toolbar-less
   // DevTools "app" window.
   static Browser* CreateForDevTools(Profile* profile);
@@ -158,6 +170,7 @@
 
   Type type() const { return type_; }
   Profile* profile() const { return profile_; }
+  void set_kill_signal(int signal) { kill_signal_ = signal; };
   const std::vector<std::wstring>& user_data_dir_profiles() const;
 
 #if defined(UNIT_TEST)
@@ -231,12 +244,14 @@
       Extension* extension,
       Extension::LaunchContainer container,
       const GURL& url,
-      const FilePath& icon_id);
+      const FilePath& icon_id,
+      bool as_desktop);
 
   // Open an application for |extension| in a new application window or panel.
   static TabContents* OpenApplicationWindow(Profile* profile,
                                             GURL& url,
-                                            const FilePath& icon_id);
+                                            const FilePath& icon_id,
+                                            bool as_desktop);
 
   // Open an application for |extension| in a new application tab.  Returns
   // NULL if there are no appropriate existing browser windows for |profile|.
@@ -1049,6 +1064,9 @@
   // Stores the last blocked command id when |block_command_execution_| is true.
   int last_blocked_command_id_;
 
+  // Stores the kill signal used to shutdown the browser.
+  int kill_signal_;
+
   // Stores the disposition type of the last blocked command.
   WindowOpenDisposition last_blocked_command_disposition_;
 
Index: src/chrome/browser/browser_init.cc
===================================================================
--- src.orig/chrome/browser/browser_init.cc	2010-08-16 15:50:48.293646917 +0200
+++ src/chrome/browser/browser_init.cc	2010-08-16 16:06:16.523641140 +0200
@@ -558,7 +558,8 @@
 
     if (process_startup) {
       if (browser_defaults::kOSSupportsOtherBrowsers &&
-          !command_line_.HasSwitch(switches::kNoDefaultBrowserCheck)) {
+          !command_line_.HasSwitch(switches::kNoDefaultBrowserCheck) &&
+          !IsDesktopLaunch()) {
         // Check whether we are the default browser.
         CheckDefaultBrowser(profile);
       }
@@ -620,6 +621,13 @@
   return false;
 }
 
+bool BrowserInit::LaunchWithProfile::IsDesktopLaunch() {
+  if (command_line_.HasSwitch(switches::kDesktop)) {
+    return true;
+  }
+  return false;
+}
+
 bool BrowserInit::LaunchWithProfile::OpenApplicationWindow(Profile* profile) {
   std::string url_string, app_id;
   if (!IsAppLaunch(&url_string, &app_id))
@@ -652,7 +660,7 @@
     if (policy->IsWebSafeScheme(url.scheme()) ||
         url.SchemeIs(chrome::kFileScheme)) {
       std::string icon_id(command_line_.GetSwitchValueASCII(switches::kIconId));
-      Browser::OpenApplicationWindow(profile, url, FilePath(icon_id));
+      Browser::OpenApplicationWindow(profile, url, FilePath(icon_id), IsDesktopLaunch());
       return true;
     }
   }
Index: src/chrome/browser/browser_init.h
===================================================================
--- src.orig/chrome/browser/browser_init.h	2010-08-16 15:50:48.283647410 +0200
+++ src/chrome/browser/browser_init.h	2010-08-16 16:04:13.953646380 +0200
@@ -148,6 +148,9 @@
     // In this case |app_url| or |app_id| are populated if they're non-null.
     bool IsAppLaunch(std::string* app_url, std::string* app_id);
 
+    // If the process was launched with the desktop flag, return true.
+    bool IsDesktopLaunch();
+
     // If IsAppLaunch is true, tries to open an application window.
     // If the app is specified to start in a tab, or IsAppLaunch is false,
     // returns false to specify default processing.
Index: src/chrome/browser/gtk/browser_titlebar.cc
===================================================================
--- src.orig/chrome/browser/gtk/browser_titlebar.cc	2010-08-16 15:50:48.323641240 +0200
+++ src/chrome/browser/gtk/browser_titlebar.cc	2010-08-16 16:04:13.953646380 +0200
@@ -279,7 +279,7 @@
   Singleton<GConfTitlebarListener>()->SetTitlebarButtons(this);
 
   if (browser_window_->browser()->profile()->IsOffTheRecord() &&
-      browser_window_->browser()->type() == Browser::TYPE_NORMAL) {
+      browser_window_->browser()->type() & Browser::TYPE_NORMAL) {
     GtkWidget* spy_guy = gtk_image_new_from_pixbuf(GetOTRAvatar());
     gtk_misc_set_alignment(GTK_MISC(spy_guy), 0.0, 1.0);
     GtkWidget* spy_frame = gtk_alignment_new(0.0, 0.0, 1.0, 1.0);
@@ -294,7 +294,7 @@
 
   // We use an alignment to control the titlebar height.
   titlebar_alignment_ = gtk_alignment_new(0.0, 0.0, 1.0, 1.0);
-  if (browser_window_->browser()->type() == Browser::TYPE_NORMAL) {
+  if (browser_window_->browser()->type() & Browser::TYPE_NORMAL) {
     gtk_box_pack_start(GTK_BOX(container_hbox_), titlebar_alignment_, TRUE,
                        TRUE, 0);
 
@@ -493,8 +493,8 @@
 
   // Note: this isn't browser_window_->browser()->type() & Browser::TYPE_APP
   // because we want to exclude Browser::TYPE_APP_POPUP.
-  if (browser_window_->browser()->type() == Browser::TYPE_APP ||
-      browser_window_->browser()->type() == Browser::TYPE_APP_PANEL) {
+  if (browser_window_->browser()->type() & Browser::TYPE_APP &&
+      browser_window_->browser()->type() != Browser::TYPE_APP_PANEL) {
     // Update the system app icon.  We don't need to update the icon in the top
     // left of the custom frame, that will get updated when the throbber is
     // updated.
@@ -538,8 +538,8 @@
 
     // Note: this isn't browser_window_->browser()->type() & Browser::TYPE_APP
     // because we want to exclude Browser::TYPE_APP_POPUP.
-    if (browser_window_->browser()->type() == Browser::TYPE_APP ||
-        browser_window_->browser()->type() == Browser::TYPE_APP_PANEL) {
+    if (browser_window_->browser()->type() & Browser::TYPE_APP &&
+        browser_window_->browser()->type() != Browser::TYPE_APP_PANEL) {
       SkBitmap icon = browser_window_->browser()->GetCurrentPageIcon();
       if (icon.empty()) {
         // Fallback to the Chromium icon if the page has no icon.
Index: src/chrome/browser/gtk/browser_toolbar_gtk.cc
===================================================================
--- src.orig/chrome/browser/gtk/browser_toolbar_gtk.cc	2010-08-16 15:50:48.323641240 +0200
+++ src/chrome/browser/gtk/browser_toolbar_gtk.cc	2010-08-16 16:04:13.953646380 +0200
@@ -658,7 +658,7 @@
 
 bool BrowserToolbarGtk::ShouldOnlyShowLocation() const {
   // If we're a popup window, only show the location bar (omnibox).
-  return browser_->type() != Browser::TYPE_NORMAL;
+  return !(browser_->type() & Browser::TYPE_NORMAL);
 }
 
 void BrowserToolbarGtk::AnimationEnded(const Animation* animation) {
Index: src/chrome/browser/gtk/browser_window_gtk.cc
===================================================================
--- src.orig/chrome/browser/gtk/browser_window_gtk.cc	2010-08-16 15:50:48.313651237 +0200
+++ src/chrome/browser/gtk/browser_window_gtk.cc	2010-08-16 16:33:36.803641640 +0200
@@ -771,7 +771,7 @@
 }
 
 void BrowserWindowGtk::LoadingAnimationCallback() {
-  if (browser_->type() == Browser::TYPE_NORMAL) {
+  if (browser_->type() & Browser::TYPE_NORMAL) {
     // Loading animations are shown in the tab for tabbed windows.  We check the
     // browser type instead of calling IsTabStripVisible() because the latter
     // will return false for fullscreen windows, but we still need to update
@@ -822,6 +822,21 @@
   return fullscreen_exit_bubble_.get() ? true : false;
 }
 
+void BrowserWindowGtk::SetDesktop() {
+  GdkWindow* gdkWindow;
+  XID window;
+
+  gdkWindow = GTK_WIDGET( window_ )->window;
+  window = x11_util::GetX11WindowFromGdkWindow( gdkWindow );
+  x11_util::ChangeProperty( window,
+      "_NET_WM_WINDOW_TYPE", "_NET_WM_WINDOW_TYPE_DESKTOP" );
+
+  gtk_window_stick( window_ );
+  gtk_window_maximize( window_ );
+  gtk_window_set_wmclass( window_, "desktop_window", "chromium" );
+  gtk_window_set_resizable( window_, FALSE );
+}
+
 LocationBar* BrowserWindowGtk::GetLocationBar() const {
   return toolbar_->GetLocationBar();
 }
@@ -2101,8 +2116,7 @@
 bool BrowserWindowGtk::UseCustomFrame() {
   // We don't use the custom frame for app mode windows or app window popups.
   return use_custom_frame_pref_.GetValue() &&
-      browser_->type() != Browser::TYPE_APP &&
-      browser_->type() != Browser::TYPE_APP_POPUP;
+      !(browser_->type() & Browser::TYPE_APP);
 }
 
 void BrowserWindowGtk::PlaceBookmarkBar(bool is_floating) {
Index: src/app/x11_util.cc
===================================================================
--- src.orig/app/x11_util.cc	2010-08-16 15:50:48.253647525 +0200
+++ src/app/x11_util.cc	2010-08-16 16:04:13.953646380 +0200
@@ -332,6 +332,36 @@
   return true;
 }
 
+bool ChangeProperty(
+    XID window, const std::string& property_name, const std::string& set_name) {
+  Atom property_atom = gdk_x11_get_xatom_by_name_for_display(
+      gdk_display_get_default(), property_name.c_str());
+  Atom set_atom = gdk_x11_get_xatom_by_name_for_display(
+      gdk_display_get_default(), set_name.c_str());
+  Atom type = XA_ATOM;
+  int format = 32;
+  int mode = PropModeReplace;
+  long unsigned int num_items = 1;
+
+  LOG(INFO) << "Setting X desktop mode hint";
+
+  int result = XChangeProperty( GDK_DISPLAY_XDISPLAY( gdk_display_get_default() ),
+                                window,
+                                property_atom,
+                                type,
+                                format,
+                                mode,
+                                (guchar*) &set_atom,
+                                num_items);
+
+  LOG(INFO) << "XChangeProperty returned: " << result;
+
+  if (result != Success)
+    return false;
+
+  return true;
+}
+
 XID GetParentWindow(XID window) {
   XID root = None;
   XID parent = None;
Index: src/app/x11_util.h
===================================================================
--- src.orig/app/x11_util.h	2010-08-16 15:50:48.253647525 +0200
+++ src/app/x11_util.h	2010-08-16 16:04:13.953646380 +0200
@@ -87,6 +87,8 @@
                          std::vector<int>* value);
 bool GetStringProperty(
     XID window, const std::string& property_name, std::string* value);
+bool ChangeProperty(
+    XID window, const std::string& property_name, const std::string& set_name);
 
 // Get |window|'s parent window, or None if |window| is the root window.
 XID GetParentWindow(XID window);
Index: src/chrome/browser/browser_window.h
===================================================================
--- src.orig/chrome/browser/browser_window.h	2010-08-16 15:50:48.303641383 +0200
+++ src/chrome/browser/browser_window.h	2010-08-16 16:04:13.953646380 +0200
@@ -125,6 +125,9 @@
   // Returns true if the fullscreen bubble is visible.
   virtual bool IsFullscreenBubbleVisible() const = 0;
 
+  // Sets the desktop-mode state
+  virtual void SetDesktop() = 0;
+
   // Returns the location bar.
   virtual LocationBar* GetLocationBar() const = 0;
 
Index: src/chrome/browser/gtk/browser_window_gtk.h
===================================================================
--- src.orig/chrome/browser/gtk/browser_window_gtk.h	2010-08-16 15:50:48.303641383 +0200
+++ src/chrome/browser/gtk/browser_window_gtk.h	2010-08-16 16:04:13.953646380 +0200
@@ -69,6 +69,7 @@
   virtual void SetFullscreen(bool fullscreen);
   virtual bool IsFullscreen() const;
   virtual bool IsFullscreenBubbleVisible() const;
+  virtual void SetDesktop();
   virtual LocationBar* GetLocationBar() const;
   virtual void SetFocusToLocationBar(bool select_all);
   virtual void UpdateReloadStopState(bool is_loading, bool force);
Index: src/chrome/common/chrome_switches.cc
===================================================================
--- src.orig/chrome/common/chrome_switches.cc	2010-08-16 15:50:48.343643415 +0200
+++ src/chrome/common/chrome_switches.cc	2010-08-16 16:04:13.953646380 +0200
@@ -93,6 +93,9 @@
 // Enables support to debug printing subsystem.
 const char kDebugPrint[]                    = "debug-print";
 
+// Specifies that the browser should be launched in "X Desktop" mode.
+const char kDesktop[]                       = "desktop";
+
 // Triggers a pletora of diagnostic modes.
 const char kDiagnostics[]                   = "diagnostics";
 
Index: src/chrome/common/chrome_switches.h
===================================================================
--- src.orig/chrome/common/chrome_switches.h	2010-08-16 15:50:48.333642098 +0200
+++ src/chrome/common/chrome_switches.h	2010-08-16 16:04:13.953646380 +0200
@@ -42,6 +42,7 @@
 extern const char kCloudPrintServiceURL[];
 extern const char kCountry[];
 extern const char kDebugPrint[];
+extern const char kDesktop[];
 extern const char kDiagnostics[];
 extern const char kDisableAltWinstation[];
 extern const char kDisableApplicationCache[];
Index: src/chrome/browser/browser_list.h
===================================================================
--- src.orig/chrome/browser/browser_list.h	2010-08-16 15:50:48.273644134 +0200
+++ src/chrome/browser/browser_list.h	2010-08-16 16:04:13.953646380 +0200
@@ -99,13 +99,13 @@
   // posting a WM_CLOSE message, otherwise the windows are closed directly. In
   // almost all cases you'll want to use true, the one exception is ending
   // the session. use_post should only be false when invoked from end session.
-  static void CloseAllBrowsers(bool use_post);
+  static void CloseAllBrowsers(bool use_post, int signal);
 
   // Closes all browsers and exits.  This is equivalent to
   // CloseAllBrowsers(true) on platforms where the application exits when no
   // more windows are remaining.  On other platforms (the Mac), this will
   // additionally exit the application.
-  static void CloseAllBrowsersAndExit();
+  static void CloseAllBrowsersAndExit(int signal);
 
   // Begins shutdown of the application when the Windows session is ending.
   static void WindowsSessionEnding();
Index: src/chrome/browser/browser_list.cc
===================================================================
--- src.orig/chrome/browser/browser_list.cc	2010-08-16 15:50:48.283647410 +0200
+++ src/chrome/browser/browser_list.cc	2010-08-16 16:04:13.953646380 +0200
@@ -209,20 +209,23 @@
 }
 
 // static
-void BrowserList::CloseAllBrowsers(bool use_post) {
+void BrowserList::CloseAllBrowsers(bool use_post, int signal) {
   // Before we close the browsers shutdown all session services. That way an
   // exit can restore all browsers open before exiting.
   ProfileManager::ShutdownSessionServices();
+  LOG(INFO) << "Processing kill signal " << signal;
 
   for (BrowserList::const_iterator i = BrowserList::begin();
        i != BrowserList::end();) {
     if (use_post) {
+      (*i)->set_kill_signal(signal);
       (*i)->window()->Close();
       ++i;
     } else {
       // This path is hit during logoff/power-down. In this case we won't get
       // a final message and so we force the browser to be deleted.
       Browser* browser = *i;
+      browser->set_kill_signal(signal);
       browser->window()->Close();
       // Close doesn't immediately destroy the browser
       // (Browser::TabStripEmpty() uses invoke later) but when we're ending the
@@ -242,7 +245,7 @@
 }
 
 // static
-void BrowserList::CloseAllBrowsersAndExit() {
+void BrowserList::CloseAllBrowsersAndExit(int signal) {
   NotificationService::current()->Notify(
       NotificationType::APP_EXITING,
       NotificationService::AllSources(),
@@ -250,7 +253,7 @@
 
 #if !defined(OS_MACOSX)
   // On most platforms, closing all windows causes the application to exit.
-  CloseAllBrowsers(true);
+  CloseAllBrowsers(true, signal);
 #else
   // On the Mac, the application continues to run once all windows are closed.
   // Terminate will result in a CloseAllBrowsers(true) call, and once (and if)
@@ -278,7 +281,7 @@
   g_browser_process->EndSession();
 
   // Close all the browsers.
-  BrowserList::CloseAllBrowsers(false);
+  BrowserList::CloseAllBrowsers(false, 0);
 
   // Send out notification. This is used during testing so that the test harness
   // can properly shutdown before we exit.
Index: src/chrome/browser/automation/automation_provider.cc
===================================================================
--- src.orig/chrome/browser/automation/automation_provider.cc	2010-08-16 15:50:48.293646917 +0200
+++ src/chrome/browser/automation/automation_provider.cc	2010-08-16 16:04:13.953646380 +0200
@@ -3333,7 +3333,7 @@
 }
 
 void TestingAutomationProvider::OnChannelError() {
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
   AutomationProvider::OnChannelError();
 }
 
Index: src/chrome/browser/browser_process_impl.cc
===================================================================
--- src.orig/chrome/browser/browser_process_impl.cc	2010-08-16 16:46:21.893641072 +0200
+++ src/chrome/browser/browser_process_impl.cc	2010-08-16 16:46:36.433641575 +0200
@@ -594,7 +594,7 @@
     new_cl->AppendSwitch(switches::kRestoreBackgroundContents);
 
   DLOG(WARNING) << "Shutting down current instance of the browser.";
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
 
   // Transfer ownership to Upgrade.
   Upgrade::SetNewCommandLine(new_cl.release());
Index: src/chrome/browser/chromeos/login/screen_locker.cc
===================================================================
--- src.orig/chrome/browser/chromeos/login/screen_locker.cc	2010-08-16 16:46:21.873646586 +0200
+++ src/chrome/browser/chromeos/login/screen_locker.cc	2010-08-16 16:46:31.383641436 +0200
@@ -563,7 +563,7 @@
 void ScreenLocker::Signout() {
   if (!error_info_) {
     // TODO(oshima): record this action in user metrics.
-    BrowserList::CloseAllBrowsersAndExit();
+    BrowserList::CloseAllBrowsersAndExit(0);
 
     // Don't hide yet the locker because the chrome screen may become visible
     // briefly.
Index: src/chrome/browser/gtk/update_recommended_dialog.cc
===================================================================
--- src.orig/chrome/browser/gtk/update_recommended_dialog.cc	2010-08-16 16:46:21.923646470 +0200
+++ src/chrome/browser/gtk/update_recommended_dialog.cc	2010-08-16 16:46:45.523640798 +0200
@@ -70,7 +70,7 @@
     PrefService* pref_service = g_browser_process->local_state();
     pref_service->SetBoolean(prefs::kRestartLastSessionOnShutdown, true);
 
-    BrowserList::CloseAllBrowsersAndExit();
+    BrowserList::CloseAllBrowsersAndExit(0);
   }
 
   delete this;
Index: src/chrome/browser/views/update_recommended_message_box.cc
===================================================================
--- src.orig/chrome/browser/views/update_recommended_message_box.cc	2010-08-16 16:46:21.913641404 +0200
+++ src/chrome/browser/views/update_recommended_message_box.cc	2010-08-16 16:46:41.143640805 +0200
@@ -30,7 +30,7 @@
   PrefService* pref_service = g_browser_process->local_state();
   pref_service->SetBoolean(prefs::kRestartLastSessionOnShutdown, true);
 
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
 
   return true;
 }
Index: src/chrome/browser/browser_main_posix.cc
===================================================================
--- src.orig/chrome/browser/browser_main_posix.cc	2010-08-16 16:49:09.553640410 +0200
+++ src/chrome/browser/browser_main_posix.cc	2010-08-16 16:50:14.463640650 +0200
@@ -109,7 +109,7 @@
 
   if (!ChromeThread::PostTask(
       ChromeThread::UI, FROM_HERE,
-      NewRunnableFunction(BrowserList::CloseAllBrowsersAndExit))) {
+      NewRunnableFunction(BrowserList::CloseAllBrowsersAndExit, 0))) {
     // Without a UI thread to post the exit task to, there aren't many
     // options.  Raise the signal again.  The default handler will pick it up
     // and cause an ungraceful exit.
