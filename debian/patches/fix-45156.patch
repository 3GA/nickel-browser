Index: src/net/websockets/websocket_throttle.cc
===================================================================
--- src.orig/net/websockets/websocket_throttle.cc	2010-05-12 17:13:55.944271485 +0200
+++ src/net/websockets/websocket_throttle.cc	2010-05-12 17:14:01.344265914 +0200
@@ -6,6 +6,7 @@
 
 #include <string>
 
+#include "base/hash_tables.h"
 #include "base/message_loop.h"
 #include "base/ref_counted.h"
 #include "base/singleton.h"
@@ -53,10 +54,17 @@
 void WebSocketThrottle::PutInQueue(WebSocketJob* job) {
   queue_.push_back(job);
   const AddressList& address_list = job->address_list();
+  base::hash_set<std::string> address_set;
   for (const struct addrinfo* addrinfo = address_list.head();
        addrinfo != NULL;
        addrinfo = addrinfo->ai_next) {
     std::string addrkey = AddrinfoToHashkey(addrinfo);
+
+    // If |addrkey| is already processed, don't do it again.
+    if (address_set.find(addrkey) != address_set.end())
+      continue;
+    address_set.insert(addrkey);
+
     ConnectingAddressMap::iterator iter = addr_map_.find(addrkey);
     if (iter == addr_map_.end()) {
       ConnectingQueue* queue = new ConnectingQueue();
@@ -65,6 +73,7 @@
     } else {
       iter->second->push_back(job);
       job->SetWaiting();
+      DLOG(INFO) << "Waiting on " << addrkey;
     }
   }
 }
@@ -83,12 +92,19 @@
   if (!in_queue)
     return;
   const AddressList& address_list = job->address_list();
+  base::hash_set<std::string> address_set;
   for (const struct addrinfo* addrinfo = address_list.head();
        addrinfo != NULL;
        addrinfo = addrinfo->ai_next) {
     std::string addrkey = AddrinfoToHashkey(addrinfo);
+    // If |addrkey| is already processed, don't do it again.
+    if (address_set.find(addrkey) != address_set.end())
+      continue;
+    address_set.insert(addrkey);
+
     ConnectingAddressMap::iterator iter = addr_map_.find(addrkey);
     DCHECK(iter != addr_map_.end());
+
     ConnectingQueue* queue = iter->second;
     // Job may not be front of queue when job is closed early while waiting.
     for (ConnectingQueue::iterator iter = queue->begin();
Index: src/net/websockets/websocket_throttle_unittest.cc
===================================================================
--- src.orig/net/websockets/websocket_throttle_unittest.cc	2010-05-12 17:13:55.954270970 +0200
+++ src/net/websockets/websocket_throttle_unittest.cc	2010-05-12 17:14:01.344265914 +0200
@@ -279,4 +279,29 @@
   MessageLoopForIO::current()->RunAllPending();
 }
 
+TEST_F(WebSocketThrottleTest, NoThrottleForDuplicateAddress) {
+  DummySocketStreamDelegate delegate;
+
+  // For localhost: 127.0.0.1, 127.0.0.1
+  struct addrinfo* addr = AddAddr(127, 0, 0, 1, NULL);
+  addr = AddAddr(127, 0, 0, 1, addr);
+  scoped_refptr<WebSocketJob> w1 = new WebSocketJob(&delegate);
+  scoped_refptr<SocketStream> s1 =
+      new SocketStream(GURL("ws://localhost/"), w1.get());
+  w1->InitSocketStream(s1.get());
+  WebSocketThrottleTest::MockSocketStreamConnect(s1, addr);
+  DeleteAddrInfo(addr);
+
+  DLOG(INFO) << "socket1";
+  TestCompletionCallback callback_s1;
+  // Trying to open connection to localhost will start without wait.
+  EXPECT_EQ(OK, w1->OnStartOpenConnection(s1, &callback_s1));
+
+  DLOG(INFO) << "socket1 close";
+  w1->OnClose(s1.get());
+  s1->DetachDelegate();
+  DLOG(INFO) << "Done";
+  MessageLoopForIO::current()->RunAllPending();
+}
+
 }
