--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -223,6 +223,7 @@
       block_command_execution_(false),
       last_blocked_command_id_(-1),
       last_blocked_command_disposition_(CURRENT_TAB),
+      kill_signal_(0),
       pending_web_app_action_(NONE),
       ALLOW_THIS_IN_INITIALIZER_LIST(
           tab_restore_service_delegate_(
@@ -410,6 +411,15 @@
 }
 
 // static
+Browser* Browser::CreateForAppDesktop(const std::string& app_name,
+                                      Profile* profile) {
+  Browser* browser = new Browser(TYPE_APP_DESKTOP, profile);
+  browser->app_name_ = app_name;
+  browser->CreateBrowserWindow();
+  return browser;
+}
+
+// static
 Browser* Browser::CreateForDevTools(Profile* profile) {
   CreateParams params(TYPE_POPUP, profile);
   params.app_name = DevToolsWindow::kDevToolsApp;
@@ -557,7 +567,7 @@
     case extension_misc::LAUNCH_WINDOW:
     case extension_misc::LAUNCH_PANEL:
       tab = Browser::OpenApplicationWindow(profile, extension, container,
-                                           GURL(), empty_icon, NULL);
+                                           GURL(), empty_icon, false, NULL);
       break;
     case extension_misc::LAUNCH_TAB: {
       tab = Browser::OpenApplicationTab(profile, extension, disposition);
@@ -577,6 +587,7 @@
     extension_misc::LaunchContainer container,
     const GURL& url_input,
     const FilePath& icon_id,
+    bool as_desktop,
     Browser** app_browser) {
   GURL url;
   if (!url_input.is_empty()) {
@@ -604,8 +615,12 @@
     window_bounds.set_height(extension->launch_height());
   }
 
-  Browser* browser = Browser::CreateForApp(type, app_name, window_bounds,
-                                           profile);
+  Browser* browser;
+  if (as_desktop)
+    browser = Browser::CreateForAppDesktop(app_name, profile);
+  else
+    browser = Browser::CreateForApp(type, app_name, window_bounds, profile);
+
 
   if (app_browser)
     *app_browser = browser;
@@ -616,6 +631,9 @@
       profile->GetPrefs()->SetFilePath(icon_pref_key.c_str(), icon_id);
   }
 
+  if (browser->type_ & TYPE_DESKTOP)
+    browser->window()->SetDesktop();
+
   TabContentsWrapper* wrapper =
       browser->AddSelectedTabWithURL(url, PageTransition::START_PAGE);
   TabContents* contents = wrapper->tab_contents();
@@ -632,6 +650,7 @@
 TabContents* Browser::OpenAppShortcutWindow(Profile* profile,
                                             const GURL& url,
                                             const FilePath& icon_id,
+                                            bool as_desktop,
                                             bool update_shortcut) {
   Browser* app_browser;
   TabContents* tab = OpenApplicationWindow(
@@ -640,6 +659,7 @@
       extension_misc::LAUNCH_WINDOW,
       url,
       icon_id,
+      as_desktop,
       &app_browser);
 
   if (!tab)
@@ -952,7 +972,9 @@
 }
 
 bool Browser::ShouldCloseWindow() {
-  if (!CanCloseWithInProgressDownloads())
+  if (!CanCloseWithInProgressDownloads()
+    || (this->type() & TYPE_DESKTOP && !kill_signal_)
+  )
     return false;
 
   if (HasCompletedUnloadProcessing())
@@ -1353,6 +1375,11 @@
 
     if (!is_app())
       features |= FEATURE_LOCATIONBAR;
+
+    if (is_type_desktop()) {
+      features &= ~FEATURE_TITLEBAR;
+      features &= ~FEATURE_DOWNLOADSHELF;
+    }
   }
   return !!(features & feature);
 }
@@ -1676,7 +1703,7 @@
     }
   }
 #endif
-  BrowserList::Exit();
+  BrowserList::Exit(0);
 }
 
 void Browser::BookmarkCurrentPage() {
@@ -3311,6 +3338,10 @@
     return;
   }
 
+  if (this->type_ & TYPE_DESKTOP && !this->kill_signal_) {
+    proceed = false;
+  }
+
   if (!proceed) {
     CancelWindowClose();
     *proceed_to_fire_unload = false;
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -85,6 +85,7 @@
     TYPE_TABBED = 1,
     TYPE_POPUP = 2,
     TYPE_PANEL = 3,
+    TYPE_DESKTOP = 8,
   };
 
   // Possible elements of the Browser window.
@@ -146,6 +147,11 @@
   // window is created by this function call.
   static Browser* Create(Profile* profile);
 
+  // Creates a normal tabbed browser with the specified profile, but set as
+  // the user's desktop. The Browser's window is created by this function
+  // call.
+  static Browser* CreateForDesktop(Profile* profile);
+
   // Like Create, but creates a browser of the specified parameters.
   static Browser* CreateWithParams(const CreateParams& params);
 
@@ -161,6 +167,10 @@
                                const gfx::Rect& window_bounds,
                                Profile* profile);
 
+  // Like Create, but creates a tabstrip-less and toolbar-less "app" window for
+  // the specified app, as the user's desktop.
+  static Browser* CreateForAppDesktop(const std::string& app_name, Profile* profile);
+
   // Like Create, but creates a tabstrip-less and toolbar-less
   // DevTools "app" window.
   static Browser* CreateForDevTools(Profile* profile);
@@ -187,6 +197,7 @@
   Type type() const { return type_; }
   const std::string& app_name() const { return app_name_; }
   Profile* profile() const { return profile_; }
+  void set_kill_signal(int signal) { kill_signal_ = signal; };
   const std::vector<std::wstring>& user_data_dir_profiles() const;
   gfx::Rect override_bounds() const { return override_bounds_; }
 
@@ -260,6 +271,7 @@
       extension_misc::LaunchContainer container,
       const GURL& url,
       const FilePath& icon_id,
+      bool as_desktop,
       Browser** app_browser);
 
   // Open |url| in an app shortcut window.  If |update_shortcut| is true,
@@ -270,6 +282,8 @@
   // Browser::OpenApplicationWindow().
   static TabContents* OpenAppShortcutWindow(Profile* profile,
                                             const GURL& url,
                                             const FilePath& icon_id,
+                                            bool as_desktop,
                                             bool update_shortcut);
 
   // Open an application for |extension| using |disposition|.  Returns NULL if
@@ -753,9 +767,10 @@
   // Figure out if there are tabs that have beforeunload handlers.
   bool TabsNeedBeforeUnloadFired();
 
-  bool is_type_tabbed() const { return type_ == TYPE_TABBED; }
-  bool is_type_popup() const { return type_ == TYPE_POPUP; }
-  bool is_type_panel() const { return type_ == TYPE_PANEL; }
+  bool is_type_tabbed() const { return type_ & TYPE_TABBED; }
+  bool is_type_popup() const { return type_ & TYPE_POPUP; }
+  bool is_type_panel() const { return type_ & TYPE_PANEL; }
+  bool is_type_desktop() const { return type_ & TYPE_DESKTOP; }
 
   bool is_app() const;
   bool is_devtools() const;
@@ -1202,6 +1217,9 @@
   // Stores the disposition type of the last blocked command.
   WindowOpenDisposition last_blocked_command_disposition_;
 
+  // Stores the kill signal used to shutdown the browser.
+  int kill_signal_;
+
   // Different types of action when web app info is available.
   // OnDidGetApplicationInfo uses this to dispatch calls.
   enum WebAppAction {
--- a/chrome/browser/ui/browser_init.cc
+++ b/chrome/browser/ui/browser_init.cc
@@ -682,7 +682,8 @@
 
     if (process_startup) {
       if (browser_defaults::kOSSupportsOtherBrowsers &&
-          !command_line_.HasSwitch(switches::kNoDefaultBrowserCheck)) {
+          !command_line_.HasSwitch(switches::kNoDefaultBrowserCheck) &&
+          !IsDesktopLaunch()) {
         // Check whether we are the default browser.
         CheckDefaultBrowser(profile);
       }
@@ -766,6 +767,13 @@
   return (app_tab != NULL);
 }
 
+bool BrowserInit::LaunchWithProfile::IsDesktopLaunch() {
+  if (command_line_.HasSwitch(switches::kDesktop)) {
+    return true;
+  }
+  return false;
+}
+
 bool BrowserInit::LaunchWithProfile::OpenApplicationWindow(Profile* profile) {
   std::string url_string, app_id;
   if (!IsAppLaunch(&url_string, &app_id))
@@ -822,6 +830,7 @@
           profile,
           url,
           FilePath(icon_id),
+          IsDesktopLaunch(),
           true);  // Update app info.
       return (app_tab != NULL);
     }
--- a/chrome/browser/ui/browser_init.h
+++ b/chrome/browser/ui/browser_init.h
@@ -135,6 +135,9 @@
     // In this case |app_url| or |app_id| are populated if they're non-null.
     bool IsAppLaunch(std::string* app_url, std::string* app_id);
 
+    // If the process was launched with the desktop flag, return true.
+    bool IsDesktopLaunch();
+
     // If IsAppLaunch is true, tries to open an application window.
     // If the app is specified to start in a tab, or IsAppLaunch is false,
     // returns false to specify default processing.
--- a/chrome/browser/ui/gtk/browser_window_gtk.cc
+++ b/chrome/browser/ui/gtk/browser_window_gtk.cc
@@ -833,6 +833,21 @@
   return fullscreen_exit_bubble_.get() ? true : false;
 }
 
+void BrowserWindowGtk::SetDesktop() {
+  GdkWindow* gdkWindow;
+  XID window;
+
+  gdkWindow = GTK_WIDGET( window_ )->window;
+  window = x11_util::GetX11WindowFromGdkWindow( gdkWindow );
+  x11_util::ChangeProperty( window,
+      "_NET_WM_WINDOW_TYPE", "_NET_WM_WINDOW_TYPE_DESKTOP" );
+
+  gtk_window_stick( window_ );
+  gtk_window_maximize( window_ );
+  gtk_window_set_wmclass( window_, "desktop_window", "chromium" );
+  gtk_window_set_resizable( window_, FALSE );
+}
+
 LocationBar* BrowserWindowGtk::GetLocationBar() const {
   return toolbar_->GetLocationBar();
 }
--- a/ui/base/x/x11_util.cc
+++ b/ui/base/x/x11_util.cc
@@ -349,6 +349,36 @@
   return true;
 }
 
+bool ChangeProperty(
+    XID window, const std::string& property_name, const std::string& set_name) {
+  Atom property_atom = gdk_x11_get_xatom_by_name_for_display(
+      gdk_display_get_default(), property_name.c_str());
+  Atom set_atom = gdk_x11_get_xatom_by_name_for_display(
+      gdk_display_get_default(), set_name.c_str());
+  Atom type = XA_ATOM;
+  int format = 32;
+  int mode = PropModeReplace;
+  long unsigned int num_items = 1;
+
+  LOG(INFO) << "Setting X desktop mode hint";
+
+  int result = XChangeProperty( GDK_DISPLAY_XDISPLAY( gdk_display_get_default() ),
+                                window,
+                                property_atom,
+                                type,
+                                format,
+                                mode,
+                                (guchar*) &set_atom,
+                                num_items);
+
+  LOG(INFO) << "XChangeProperty returned: " << result;
+
+  if (result != Success)
+    return false;
+
+  return true;
+}
+
 XID GetParentWindow(XID window) {
   XID root = None;
   XID parent = None;
--- a/ui/base/x/x11_util.h
+++ b/ui/base/x/x11_util.h
@@ -87,6 +87,8 @@
                           std::vector<Atom>* value);
 bool GetStringProperty(
     XID window, const std::string& property_name, std::string* value);
+bool ChangeProperty(
+    XID window, const std::string& property_name, const std::string& set_name);
 
 // Get |window|'s parent window, or None if |window| is the root window.
 XID GetParentWindow(XID window);
--- a/chrome/browser/ui/browser_window.h
+++ b/chrome/browser/ui/browser_window.h
@@ -143,6 +143,9 @@
   // Returns true if the fullscreen bubble is visible.
   virtual bool IsFullscreenBubbleVisible() const = 0;
 
+  // Sets the desktop-mode state
+  virtual void SetDesktop() = 0;
+
   // Returns the location bar.
   virtual LocationBar* GetLocationBar() const = 0;
 
--- a/chrome/browser/ui/gtk/browser_window_gtk.h
+++ b/chrome/browser/ui/gtk/browser_window_gtk.h
@@ -79,6 +79,7 @@
   virtual void SetFullscreen(bool fullscreen);
   virtual bool IsFullscreen() const;
   virtual bool IsFullscreenBubbleVisible() const;
+  virtual void SetDesktop();
   virtual LocationBar* GetLocationBar() const;
   virtual void SetFocusToLocationBar(bool select_all);
   virtual void UpdateReloadStopState(bool is_loading, bool force);
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -162,6 +162,9 @@
 // device management backend.
 const char kDeviceManagementUrl[]           = "device-management-url";
 
+// Specifies that the browser should be launched in "X Desktop" mode.
+const char kDesktop[]                       = "desktop";
+
 // Triggers a pletora of diagnostic modes.
 const char kDiagnostics[]                   = "diagnostics";
 
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -59,6 +59,7 @@
 extern const char kDebugDevToolsFrontend[];
 extern const char kDebugEnableFrameToggle[];
 extern const char kDebugPrint[];
+extern const char kDesktop[];
 extern const char kDeviceManagementUrl[];
 extern const char kDiagnostics[];
 extern const char kDisableAcceleratedLayers[];
--- a/chrome/browser/ui/browser_list.cc
+++ b/chrome/browser/ui/browser_list.cc
@@ -342,7 +342,7 @@
 #endif
 
 // static
-void BrowserList::CloseAllBrowsers() {
+void BrowserList::CloseAllBrowsers(int signal) {
   bool session_ending =
       browser_shutdown::GetShutdownType() == browser_shutdown::END_SESSION;
   bool use_post = !session_ending;
@@ -371,6 +371,7 @@
   for (BrowserList::const_iterator i = BrowserList::begin();
        i != BrowserList::end();) {
     Browser* browser = *i;
+    browser->set_kill_signal(signal);
     browser->window()->Close();
     if (use_post) {
       ++i;
@@ -395,7 +396,7 @@
 }
 
 // static
-void BrowserList::Exit() {
+void BrowserList::Exit(int signal) {
 #if defined(OS_CHROMEOS)
   signout_ = true;
   // Fast shutdown for ChromeOS when there's no unload processing to be done.
@@ -406,11 +407,11 @@
     return;
   }
 #endif
-  CloseAllBrowsersAndExit();
+  CloseAllBrowsersAndExit(signal);
 }
 
 // static
-void BrowserList::CloseAllBrowsersAndExit() {
+void BrowserList::CloseAllBrowsersAndExit(int signal) {
   MarkAsCleanShutdown();  // Don't notify users of crashes beyond this point.
   NotificationService::current()->Notify(
       NotificationType::APP_EXITING,
@@ -419,7 +420,7 @@
 
 #if !defined(OS_MACOSX)
   // On most platforms, closing all windows causes the application to exit.
-  CloseAllBrowsers();
+  CloseAllBrowsers(signal);
 #else
   // On the Mac, the application continues to run once all windows are closed.
   // Terminate will result in a CloseAllBrowsers() call, and once (and if)
@@ -448,7 +449,7 @@
   // Write important data first.
   g_browser_process->EndSession();
 
-  BrowserList::CloseAllBrowsers();
+  BrowserList::CloseAllBrowsers(0);
 
   // Send out notification. This is used during testing so that the test harness
   // can properly shutdown before we exit.
@@ -504,7 +505,7 @@
     // (MessageLoop::current() == null).
     if (browsers_.empty() && !browser_shutdown::IsTryingToQuit() &&
         MessageLoop::current())
-      CloseAllBrowsers();
+      CloseAllBrowsers(0);
   }
 }
 
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -1142,7 +1142,7 @@
   }
 
   DLOG(WARNING) << "Shutting down current instance of the browser.";
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
 
   // Transfer ownership to Upgrade.
   upgrade_util::SetNewCommandLine(new_cl.release());
--- a/chrome/browser/ui/gtk/update_recommended_dialog.cc
+++ b/chrome/browser/ui/gtk/update_recommended_dialog.cc
@@ -60,7 +60,7 @@
     PrefService* pref_service = g_browser_process->local_state();
     pref_service->SetBoolean(prefs::kRestartLastSessionOnShutdown, true);
 
-    BrowserList::CloseAllBrowsersAndExit();
+    BrowserList::CloseAllBrowsersAndExit(0);
   }
 
   delete this;
--- a/chrome/browser/automation/testing_automation_provider.cc
+++ b/chrome/browser/automation/testing_automation_provider.cc
@@ -439,7 +439,7 @@
 void TestingAutomationProvider::OnChannelError() {
   if (!reinitialize_on_channel_error_ &&
       browser_shutdown::GetShutdownType() == browser_shutdown::NOT_VALID)
-    BrowserList::CloseAllBrowsersAndExit();
+    BrowserList::CloseAllBrowsersAndExit(0);
   AutomationProvider::OnChannelError();
 }
 
--- a/chrome/browser/background_mode_manager.cc
+++ b/chrome/browser/background_mode_manager.cc
@@ -71,7 +71,7 @@
       break;
     case IDC_EXIT:
       UserMetrics::RecordAction(UserMetricsAction("Exit"));
-      BrowserList::CloseAllBrowsersAndExit();
+      BrowserList::CloseAllBrowsersAndExit(0);
       break;
     case IDC_OPTIONS:
       GetBrowserWindow()->OpenOptionsDialog();
--- a/chrome/browser/ui/views/about_chrome_view.cc
+++ b/chrome/browser/ui/views/about_chrome_view.cc
@@ -616,7 +616,7 @@
   // Set the flag to restore the last session on shutdown.
   PrefService* pref_service = g_browser_process->local_state();
   pref_service->SetBoolean(prefs::kRestartLastSessionOnShutdown, true);
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
 #endif
 
   return true;
--- a/chrome/browser/ui/views/update_recommended_message_box.cc
+++ b/chrome/browser/ui/views/update_recommended_message_box.cc
@@ -41,7 +41,7 @@
   chromeos::CrosLibrary::Get()->GetPowerLibrary()->RequestRestart();
   // If running the Chrome OS build, but we're not on the device, fall through
 #endif
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
 
   return true;
 }
--- a/chrome/browser/browser_main_posix.cc
+++ b/chrome/browser/browser_main_posix.cc
@@ -138,7 +138,7 @@
 
   if (!BrowserThread::PostTask(
       BrowserThread::UI, FROM_HERE,
-      NewRunnableFunction(BrowserList::CloseAllBrowsersAndExit))) {
+      NewRunnableFunction(BrowserList::CloseAllBrowsersAndExit, 0))) {
     // Without a UI thread to post the exit task to, there aren't many
     // options.  Raise the signal again.  The default handler will pick it up
     // and cause an ungraceful exit.
--- a/chrome/browser/ui/cocoa/restart_browser.mm
+++ b/chrome/browser/ui/cocoa/restart_browser.mm
@@ -46,7 +46,7 @@
     // Set the flag to restore state after the restart.
     PrefService* pref_service = g_browser_process->local_state();
     pref_service->SetBoolean(prefs::kRestartLastSessionOnShutdown, true);
-    BrowserList::CloseAllBrowsersAndExit();
+    BrowserList::CloseAllBrowsersAndExit(0);
   } else {
     NOTREACHED();
   }
--- a/chrome/browser/ui/browser_list.h
+++ b/chrome/browser/ui/browser_list.h
@@ -101,18 +101,18 @@
   static bool CanRestartForUpdate();
 
   // Called from Browser::Exit.
-  static void Exit();
+  static void Exit(int signal);
 
   // Closes all browsers and exits.  This is equivalent to
   // CloseAllBrowsers(true) on platforms where the application exits when no
   // more windows are remaining.  On other platforms (the Mac), this will
   // additionally exit the application.
-  static void CloseAllBrowsersAndExit();
+  static void CloseAllBrowsersAndExit(int signal);
 
   // Closes all browsers. If the session is ending the windows are closed
   // directly. Otherwise the windows are closed by way of posting a WM_CLOSE
   // message.
-  static void CloseAllBrowsers();
+  static void CloseAllBrowsers(int signal);
 
   // Begins shutdown of the application when the desktop session is ending.
   static void SessionEnding();
--- a/chrome/browser/ui/webui/flags_ui.cc
+++ b/chrome/browser/ui/webui/flags_ui.cc
@@ -190,7 +190,7 @@
   // Set the flag to restore state after the restart.
   PrefService* pref_service = g_browser_process->local_state();
   pref_service->SetBoolean(prefs::kRestartLastSessionOnShutdown, true);
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
 #else
   // For CrOS instead of browser restart (which is not supported) perform a full
   // sign out. Session will be only restored is user has that setting set.
--- a/chrome/browser/ui/webui/options/language_options_handler.cc
+++ b/chrome/browser/ui/webui/options/language_options_handler.cc
@@ -112,5 +112,5 @@
   // Set the flag to restore state after the restart.
   PrefService* pref_service = g_browser_process->local_state();
   pref_service->SetBoolean(prefs::kRestartLastSessionOnShutdown, true);
-  BrowserList::CloseAllBrowsersAndExit();
+  BrowserList::CloseAllBrowsersAndExit(0);
 }
